# GDG Portal å¾Œç«¯ç³»çµ±è¨­è¨ˆæ–‡æª”

## ğŸ“‹ å°ˆæ¡ˆæ¦‚è¿°

æœ¬æ–‡æª”åˆ†æ GDG on Campus NKNU Portal çš„å‰ç«¯éœ€æ±‚ï¼Œä¸¦è¦åŠƒå®Œæ•´çš„å¾Œç«¯æ¶æ§‹ï¼ŒåŒ…å« API è¨­è¨ˆã€è³‡æ–™è¡¨çµæ§‹ã€æ§åˆ¶å™¨é‚è¼¯å’Œæ¥­å‹™æ¨¡å‹ã€‚

**å°ˆæ¡ˆæŠ€è¡“æ£§ï¼š**
- å‰ç«¯ï¼šReact + Vite + Tailwind CSS + Framer Motion
- å¾Œç«¯ï¼šNode.js + Express + MySQL + Sequelize ORM
- é©—è­‰ï¼šJWT + Google OAuth 2.0
- éƒ¨ç½²ï¼šéœ€è¦è€ƒæ…® Proxy è¨­å®šå’Œç’°å¢ƒè®Šæ•¸

---

## ğŸ¯ å‰ç«¯éœ€æ±‚åˆ†æ

### ç¾æœ‰é é¢å’ŒåŠŸèƒ½

1. **é¦–é  (Home)** - å±•ç¤ºæœ€æ–°å…¬å‘Šã€çµ±è¨ˆæ•¸æ“šã€å³å°‡åˆ°ä¾†çš„æ´»å‹•
2. **å…¬å‘Šé é¢ (Announcements)** - å…¬å‘Šåˆ—è¡¨ã€æœå°‹ã€æ¨™ç±¤ç¯©é¸ã€ç½®é ‚å…¬å‘Š
3. **æ´»å‹•é é¢ (Events)** - æ´»å‹•åˆ—è¡¨ã€è¡Œäº‹æ›†æª¢è¦–ã€æ´»å‹•è©³æƒ…
4. **æ ¸å¿ƒåœ˜éšŠé é¢ (CoreTeam)** - å¹¹éƒ¨åˆ—è¡¨ã€æˆå“¡è©³æƒ…ã€åˆ†é¡ç¯©é¸
5. **ç™»å…¥/è¨»å†Šé é¢ (Auth)** - ä½¿ç”¨è€…é©—è­‰ã€Google OAuth æ•´åˆ
6. **æ´»å‹•ç›¸ç°¿ (Gallery)** - æ´»å‹•ç…§ç‰‡ã€ç¯©é¸åŠŸèƒ½
7. **æ­·å²æ´»å‹• (Historical Events)** - éå¾€æ´»å‹•è¨˜éŒ„

### å‰ç«¯ Hook ä½¿ç”¨

```javascript
// useAnnouncementData.js
GET /api/announcements?page=1&limit=5&keyword=&tags=&isPinned=true

// useEventData.js  
GET /api/events?page=1&limit=5&keyword=&tags=&future=true&sort=desc
GET /api/events/:id

// useCoreTeamData.js
GET /api/coreteam?page=1&limit=20&keyword=&categories=
GET /api/coreteam/:id
GET /api/coreteam/options/categories

// useGalleryData.js
GET /api/gallery?page=1&limit=12&keyword=&eventType=&year=&tags=
GET /api/gallery/:id
GET /api/gallery/featured?limit=6
GET /api/gallery/stats
PATCH /api/gallery/:id/view

// useAuth.js - æ–°å¢çš„èªè­‰ç³»çµ± Hook
POST /api/auth/register
POST /api/auth/login
POST /api/auth/logout
GET /api/auth/me
POST /api/auth/refresh
GET /api/auth/google
GET /api/auth/google/callback
```

### å‰ç«¯èªè­‰ç‹€æ…‹ç®¡ç†

```javascript
// AuthContext.jsx - å…¨åŸŸèªè­‰ç‹€æ…‹ç®¡ç†
const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null)
  const [isAuthenticated, setIsAuthenticated] = useState(false)
  const [loading, setLoading] = useState(true)
  
  // è‡ªå‹•è¼‰å…¥ä½¿ç”¨è€…è³‡è¨Š
  // JWT Token ç®¡ç†
  // Google OAuth è™•ç†
  // ç™»å…¥/ç™»å‡º/è¨»å†ŠåŠŸèƒ½
}
```

---

## ğŸ” ä½¿ç”¨è€…é©—è­‰ç³»çµ±æ¶æ§‹

### 1. èªè­‰æµç¨‹è¨­è¨ˆ

#### **æ··åˆé©—è­‰ç­–ç•¥**
æœ¬ç³»çµ±æ”¯æ´å…©ç¨®èªè­‰æ–¹å¼ï¼š
1. **å‚³çµ±éƒµä»¶å¯†ç¢¼èªè­‰** - é©ç”¨æ–¼éœ€è¦è‡ªè¨‚æ¬Šé™çš„å…§éƒ¨ä½¿ç”¨è€…
2. **Google OAuth 2.0 èªè­‰** - é©ç”¨æ–¼ä¸€èˆ¬è¨ªå®¢å’Œæœƒå“¡å¿«é€Ÿç™»å…¥

#### **æ¬Šé™è§’è‰²ç³»çµ± (RBAC)**
```javascript
// è§’è‰²æ¬Šé™å®šç¾©
const ROLES = {
  admin: {
    name: 'ç®¡ç†å“¡',
    permissions: ['CREATE', 'READ', 'UPDATE', 'DELETE', 'MANAGE_USERS']
  },
  member: {
    name: 'æœƒå“¡',
    permissions: ['READ', 'CREATE_COMMENT', 'REGISTER_EVENT']
  },
  guest: {
    name: 'è¨ªå®¢',
    permissions: ['READ']
  }
}
```

#### **JWT Token æ¶æ§‹**
```javascript
// Token çµæ§‹
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 3600
}

// JWT Payload
{
  "user_id": 123,
  "email": "user@example.com",
  "role": "member",
  "iat": 1640995200,
  "exp": 1640998800
}
```

### 2. Cookie ç®¡ç†ç­–ç•¥

#### **å®‰å…¨ Cookie è¨­å®š**
```javascript
// å¾Œç«¯ Cookie è¨­å®š
const cookieOptions = {
  httpOnly: true,        // é˜²æ­¢ XSS æ”»æ“Š
  secure: process.env.NODE_ENV === 'production', // HTTPS only
  sameSite: 'strict',    // CSRF ä¿è­·
  maxAge: 24 * 60 * 60 * 1000, // 24 å°æ™‚
  path: '/'
}

// è¨­å®šèªè­‰ Cookie
res.cookie('access_token', accessToken, cookieOptions)
res.cookie('refresh_token', refreshToken, {
  ...cookieOptions,
  maxAge: 7 * 24 * 60 * 60 * 1000 // 7 å¤©
})
```

#### **å‰ç«¯ Cookie è®€å–**
```javascript
// utils/cookieUtils.js
export const getCookie = (name) => {
  const value = `; ${document.cookie}`;
  const parts = value.split(`; ${name}=`);
  if (parts.length === 2) return parts.pop().split(';').shift();
}

export const deleteCookie = (name) => {
  document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
}
```

### 3. å‰ç«¯èªè­‰ Hook å¯¦ä½œ

#### **useAuth Hook å®Œæ•´å¯¦ä½œ**
```javascript
// hooks/useAuth.js
import { createContext, useContext, useState, useEffect } from 'react'

const AuthContext = createContext()

export const useAuth = () => {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider')
  }
  return context
}

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null)
  const [isAuthenticated, setIsAuthenticated] = useState(false)
  const [loading, setLoading] = useState(true)

  // åˆå§‹åŒ–ï¼šæª¢æŸ¥ç¾æœ‰ç™»å…¥ç‹€æ…‹
  useEffect(() => {
    checkAuthStatus()
  }, [])

  const checkAuthStatus = async () => {
    try {
      const response = await fetch('/api/auth/me', {
        credentials: 'include' // åŒ…å« cookies
      })
      
      if (response.ok) {
        const userData = await response.json()
        setUser(userData.user)
        setIsAuthenticated(true)
      }
    } catch (error) {
      console.error('Auth check failed:', error)
    } finally {
      setLoading(false)
    }
  }

  // è¨»å†ŠåŠŸèƒ½
  const register = async (email, password, name) => {
    try {
      const response = await fetch('/api/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ email, password, name })
      })

      const data = await response.json()
      
      if (response.ok) {
        setUser(data.user)
        setIsAuthenticated(true)
        return { success: true, user: data.user }
      } else {
        return { success: false, message: data.message }
      }
    } catch (error) {
      return { success: false, message: 'è¨»å†Šå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦' }
    }
  }

  // ç™»å…¥åŠŸèƒ½
  const login = async (email, password) => {
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ email, password })
      })

      const data = await response.json()
      
      if (response.ok) {
        setUser(data.user)
        setIsAuthenticated(true)
        return { success: true, user: data.user }
      } else {
        return { success: false, message: data.message }
      }
    } catch (error) {
      return { success: false, message: 'ç™»å…¥å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦' }
    }
  }

  // ç™»å‡ºåŠŸèƒ½
  const logout = async () => {
    try {
      await fetch('/api/auth/logout', {
        method: 'POST',
        credentials: 'include'
      })
    } catch (error) {
      console.error('Logout error:', error)
    } finally {
      setUser(null)
      setIsAuthenticated(false)
    }
  }

  // æ›´æ–°ä½¿ç”¨è€…è³‡æ–™
  const updateUser = async (userData) => {
    try {
      const response = await fetch('/api/auth/me', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(userData)
      })

      if (response.ok) {
        const updatedUser = await response.json()
        setUser(updatedUser.user)
        return { success: true, user: updatedUser.user }
      }
    } catch (error) {
      return { success: false, message: 'æ›´æ–°å¤±æ•—' }
    }
  }

  const value = {
    user,
    isAuthenticated,
    loading,
    login,
    register,
    logout,
    updateUser,
    checkAuthStatus
  }

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  )
}
```

### 4. è·¯ç”±ä¿è­·æ©Ÿåˆ¶

#### **ProtectedRoute çµ„ä»¶**
```javascript
// pages/ProtectedRoute.jsx
import { useAuth } from '../hooks/useAuth'
import { Navigate, useLocation } from 'react-router-dom'

export default function ProtectedRoute({ children, requiredRole = null }) {
  const { isAuthenticated, user, loading } = useAuth()
  const location = useLocation()

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-blue-600"></div>
      </div>
    )
  }

  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />
  }

  // è§’è‰²æ¬Šé™æª¢æŸ¥
  if (requiredRole && user?.role !== requiredRole) {
    return <Navigate to="/unauthorized" replace />
  }

  return children
}
```

#### **è·¯ç”±é…ç½®ç¤ºä¾‹**
```javascript
// App.jsx è·¯ç”±è¨­å®š
import { AuthProvider } from './hooks/useAuth'
import ProtectedRoute from './pages/ProtectedRoute'

function App() {
  return (
    <AuthProvider>
      <Routes>
        {/* å…¬é–‹è·¯ç”± */}
        <Route path="/" element={<Home />} />
        <Route path="/login" element={<LoginPage />} />
        <Route path="/register" element={<RegisterPage />} />
        
        {/* éœ€è¦ç™»å…¥çš„è·¯ç”± */}
        <Route path="/dashboard" element={
          <ProtectedRoute>
            <DashboardPage />
          </ProtectedRoute>
        } />
        
        {/* éœ€è¦ç®¡ç†å“¡æ¬Šé™çš„è·¯ç”± */}
        <Route path="/admin/*" element={
          <ProtectedRoute requiredRole="admin">
            <AdminPanel />
          </ProtectedRoute>
        } />
      </Routes>
    </AuthProvider>
  )
}
```

### 5. ä½¿ç”¨è€…å„€è¡¨æ¿å¯¦ä½œ

#### **DashboardPage çµ„ä»¶**
```javascript
// pages/dashboard/DashboardPage.jsx
import { useState } from 'react'
import { useAuth } from '../../hooks/useAuth'
import { motion } from 'framer-motion'

export default function DashboardPage() {
  const { user, updateUser, logout } = useAuth()
  const [activeTab, setActiveTab] = useState('profile')
  const [loading, setLoading] = useState(false)

  const tabs = [
    { id: 'profile', name: 'å€‹äººè³‡æ–™', icon: 'ğŸ‘¤' },
    { id: 'security', name: 'å®‰å…¨è¨­å®š', icon: 'ğŸ”’' },
    { id: 'activities', name: 'æ´»å‹•è¨˜éŒ„', icon: 'ğŸ“…' }
  ]

  const handleUpdateProfile = async (formData) => {
    setLoading(true)
    const result = await updateUser(formData)
    setLoading(false)
    
    if (result.success) {
      // é¡¯ç¤ºæˆåŠŸè¨Šæ¯
    } else {
      // é¡¯ç¤ºéŒ¯èª¤è¨Šæ¯
    }
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* å´é‚Šæ¬„å°èˆª */}
      <div className="flex">
        <aside className="w-64 bg-white shadow-sm">
          <div className="p-6">
            <div className="flex items-center space-x-3">
              <img 
                src={user?.avatarUrl || '/default-avatar.png'} 
                alt={user?.name}
                className="w-12 h-12 rounded-full"
              />
              <div>
                <h3 className="font-semibold">{user?.name}</h3>
                <p className="text-sm text-gray-500">{user?.email}</p>
              </div>
            </div>
          </div>
          
          <nav className="mt-6">
            {tabs.map((tab) => (
              <button
                key={tab.id}
                onClick={() => setActiveTab(tab.id)}
                className={`w-full flex items-center px-6 py-3 text-left hover:bg-gray-50 ${
                  activeTab === tab.id ? 'bg-blue-50 border-r-2 border-blue-500' : ''
                }`}
              >
                <span className="mr-3">{tab.icon}</span>
                {tab.name}
              </button>
            ))}
          </nav>
        </aside>

        {/* ä¸»è¦å…§å®¹å€åŸŸ */}
        <main className="flex-1 p-8">
          {activeTab === 'profile' && (
            <ProfileTab user={user} onUpdate={handleUpdateProfile} loading={loading} />
          )}
          {activeTab === 'security' && (
            <SecurityTab user={user} />
          )}
          {activeTab === 'activities' && (
            <ActivitiesTab user={user} />
          )}
        </main>
      </div>
    </div>
  )
}
```

### 6. Google OAuth æ•´åˆ

#### **å¾Œç«¯ Passport è¨­å®š**
```javascript
// config/passport.js
import passport from 'passport'
import { Strategy as GoogleStrategy } from 'passport-google-oauth20'
import User from '../model/userModel.js'

passport.use(new GoogleStrategy({
  clientID: process.env.GOOGLE_CLIENT_ID,
  clientSecret: process.env.GOOGLE_CLIENT_SECRET,
  callbackURL: "/api/auth/google/callback"
}, async (accessToken, refreshToken, profile, done) => {
  try {
    // æª¢æŸ¥ä½¿ç”¨è€…æ˜¯å¦å·²å­˜åœ¨
    let user = await User.findOne({ where: { googleId: profile.id } })
    
    if (user) {
      return done(null, user)
    }
    
    // æª¢æŸ¥æ˜¯å¦æœ‰ç›¸åŒ email çš„å¸³è™Ÿ
    user = await User.findOne({ where: { email: profile.emails[0].value } })
    
    if (user) {
      // æ›´æ–°ç¾æœ‰å¸³è™Ÿçš„ Google ID
      user.googleId = profile.id
      user.avatarUrl = profile.photos[0].value
      await user.save()
      return done(null, user)
    }
    
    // å‰µå»ºæ–°ä½¿ç”¨è€…
    user = await User.create({
      googleId: profile.id,
      name: profile.displayName,
      email: profile.emails[0].value,
      avatarUrl: profile.photos[0].value,
      role: 'member'
    })
    
    return done(null, user)
  } catch (error) {
    return done(error, null)
  }
}))
```

#### **Google OAuth è·¯ç”±**
```javascript
// routes/auth_routes.js
router.get('/google', 
  passport.authenticate('google', { scope: ['profile', 'email'] })
)

router.get('/google/callback',
  passport.authenticate('google', { session: false }),
  async (req, res) => {
    try {
      const user = req.user
      const accessToken = generateAccessToken(user)
      const refreshToken = generateRefreshToken(user)
      
      // è¨­å®š Cookie
      res.cookie('access_token', accessToken, cookieOptions)
      res.cookie('refresh_token', refreshToken, {
        ...cookieOptions,
        maxAge: 7 * 24 * 60 * 60 * 1000 // 7 å¤©
      })
      
      // é‡å®šå‘åˆ°å‰ç«¯
      res.redirect('http://localhost:3000/?login=success')
    } catch (error) {
      res.redirect('http://localhost:3000/?login=error')
    }
  }
)
```

### 7. ç’°å¢ƒè®Šæ•¸é…ç½®

#### **å®Œæ•´ .env è¨­å®š**
```bash
# /workspaces/GDG-Portal/server/.env
NODE_ENV=development
PORT=5000

# è³‡æ–™åº«è¨­å®š
DB_HOST=localhost
DB_PORT=3306
DB_NAME=gdg_portal
DB_USER=gdg_user
DB_PASSWORD=your_secure_password

# JWT è¨­å®š
JWT_SECRET=your-super-secret-jwt-key-at-least-32-characters-long
JWT_REFRESH_SECRET=your-super-secret-refresh-key-different-from-access
JWT_EXPIRES_IN=1h
JWT_REFRESH_EXPIRES_IN=7d

# Google OAuth è¨­å®š
GOOGLE_CLIENT_ID=your-google-client-id.googleusercontent.com
GOOGLE_CLIENT_SECRET=your-google-client-secret

# å‰ç«¯ URL (ç”¨æ–¼ CORS å’Œé‡å®šå‘)
FRONTEND_URL=http://localhost:3000

# Session è¨­å®š
SESSION_SECRET=your-session-secret-key

# ä¸Šå‚³è¨­å®š
UPLOAD_DIR=uploads
MAX_FILE_SIZE=5242880
```

### 8. æ¸¬è©¦å’Œä½¿ç”¨èªªæ˜

#### **æœ¬æ©Ÿé–‹ç™¼ç’°å¢ƒå•Ÿå‹•**
```bash
# 1. å•Ÿå‹•å¾Œç«¯ä¼ºæœå™¨
cd /workspaces/GDG-Portal/server
npm install
npm run dev

# 2. å•Ÿå‹•å‰ç«¯é–‹ç™¼ä¼ºæœå™¨
cd /workspaces/GDG-Portal/client
npm install
npm run dev

# 3. è¨ªå•æ‡‰ç”¨ç¨‹å¼
# å‰ç«¯: http://localhost:3000
# å¾Œç«¯ API: http://localhost:5000
```

#### **åŠŸèƒ½æ¸¬è©¦æ¸…å–®**
```bash
# ä½¿ç”¨è€…è¨»å†Šæ¸¬è©¦
curl -X POST http://localhost:5000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"test123","name":"Test User"}'

# ä½¿ç”¨è€…ç™»å…¥æ¸¬è©¦
curl -X POST http://localhost:5000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"test123"}' \
  -c cookies.txt

# ç²å–ä½¿ç”¨è€…è³‡è¨Šæ¸¬è©¦
curl -X GET http://localhost:5000/api/auth/me \
  -b cookies.txt

# Google OAuth æ¸¬è©¦
# ç›´æ¥åœ¨ç€è¦½å™¨è¨ªå•: http://localhost:5000/api/auth/google
```

#### **æ¬Šé™æ¸¬è©¦**
```javascript
// æ¸¬è©¦ä¸åŒè§’è‰²çš„ API å­˜å–
const testRoleAccess = async (role) => {
  // ç®¡ç†å“¡åŠŸèƒ½æ¸¬è©¦
  if (role === 'admin') {
    await testCreateEvent()
    await testDeleteAnnouncement()
    await testManageUsers()
  }
  
  // æœƒå“¡åŠŸèƒ½æ¸¬è©¦
  if (role === 'member') {
    await testEventRegistration()
    await testProfileUpdate()
  }
  
  // è¨ªå®¢åŠŸèƒ½æ¸¬è©¦ (ç„¡éœ€èªè­‰)
  await testPublicContent()
}
```

---

## ğŸ—ï¸ å¾Œç«¯èªè­‰ç³»çµ±å¯¦ä½œ

### 1. ä½¿ç”¨è€…æ¨¡å‹ (User Model)

#### **è³‡æ–™è¡¨çµæ§‹**
```sql
-- å·²å¯¦ä½œçš„ä½¿ç”¨è€…è¡¨
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    google_id VARCHAR(255) UNIQUE,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255), -- ç”¨æ–¼å‚³çµ±ç™»å…¥
    name VARCHAR(100) NOT NULL,
    avatar_url TEXT,
    role ENUM('admin', 'member', 'guest') DEFAULT 'guest',
    is_active BOOLEAN DEFAULT true,
    last_login TIMESTAMP NULL,
    email_verified BOOLEAN DEFAULT false,
    verification_token VARCHAR(255),
    reset_password_token VARCHAR(255),
    reset_password_expires TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

#### **Sequelize æ¨¡å‹å®šç¾©**
```javascript
// model/userModel.js - å·²å¯¦ä½œ
import { DataTypes } from 'sequelize'
import { sequelize } from '../config/database.js'
import bcrypt from 'bcryptjs'

const User = sequelize.define('User', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  googleId: {
    type: DataTypes.STRING,
    unique: true,
    allowNull: true
  },
  email: {
    type: DataTypes.STRING,
    unique: true,
    allowNull: false,
    validate: {
      isEmail: true
    }
  },
  passwordHash: {
    type: DataTypes.STRING,
    allowNull: true // Google ç™»å…¥ä½¿ç”¨è€…å¯èƒ½æ²’æœ‰å¯†ç¢¼
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  avatarUrl: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  role: {
    type: DataTypes.ENUM('admin', 'member', 'guest'),
    defaultValue: 'guest'
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    defaultValue: true
  },
  lastLogin: {
    type: DataTypes.DATE,
    allowNull: true
  },
  emailVerified: {
    type: DataTypes.BOOLEAN,
    defaultValue: false
  }
}, {
  tableName: 'users',
  timestamps: true,
  hooks: {
    beforeCreate: async (user) => {
      if (user.passwordHash) {
        user.passwordHash = await bcrypt.hash(user.passwordHash, 12)
      }
    },
    beforeUpdate: async (user) => {
      if (user.changed('passwordHash')) {
        user.passwordHash = await bcrypt.hash(user.passwordHash, 12)
      }
    }
  }
})

// å¯¦ä¾‹æ–¹æ³•
User.prototype.comparePassword = async function(candidatePassword) {
  if (!this.passwordHash) return false
  return await bcrypt.compare(candidatePassword, this.passwordHash)
}

User.prototype.toJSON = function() {
  const user = this.get()
  delete user.passwordHash
  delete user.verificationToken
  delete user.resetPasswordToken
  return user
}

export default User
```

### 2. èªè­‰æ§åˆ¶å™¨ (AuthController)

#### **å®Œæ•´å¯¦ä½œ**
```javascript
// controllers/userController.js - å·²å¯¦ä½œ
import User from '../model/userModel.js'
import { generateAccessToken, generateRefreshToken, verifyToken } from '../utils/jwt.js'
import bcrypt from 'bcryptjs'

class AuthController {
  // è¨»å†ŠåŠŸèƒ½
  async register(req, res) {
    try {
      const { email, password, name } = req.body

      // è¼¸å…¥é©—è­‰
      if (!email || !password || !name) {
        return res.status(400).json({
          success: false,
          message: 'è«‹å¡«å¯«æ‰€æœ‰å¿…å¡«æ¬„ä½'
        })
      }

      // æª¢æŸ¥å¯†ç¢¼å¼·åº¦
      if (password.length < 6) {
        return res.status(400).json({
          success: false,
          message: 'å¯†ç¢¼é•·åº¦è‡³å°‘éœ€è¦ 6 å€‹å­—å…ƒ'
        })
      }

      // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒ email
      const existingUser = await User.findOne({ where: { email } })
      if (existingUser) {
        return res.status(409).json({
          success: false,
          message: 'æ­¤é›»å­éƒµä»¶å·²è¢«è¨»å†Š'
        })
      }

      // å‰µå»ºæ–°ä½¿ç”¨è€…
      const user = await User.create({
        email,
        passwordHash: password, // æœƒåœ¨ hook ä¸­è‡ªå‹•åŠ å¯†
        name,
        role: 'member', // é è¨­ç‚ºæœƒå“¡
        emailVerified: true // ç°¡åŒ–ç‰ˆæœ¬ï¼Œç›´æ¥è¨­ç‚ºå·²é©—è­‰
      })

      // ç”Ÿæˆ JWT tokens
      const accessToken = generateAccessToken(user)
      const refreshToken = generateRefreshToken(user)

      // è¨­å®šå®‰å…¨ cookies
      const cookieOptions = {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        path: '/'
      }

      res.cookie('access_token', accessToken, {
        ...cookieOptions,
        maxAge: 60 * 60 * 1000 // 1 å°æ™‚
      })

      res.cookie('refresh_token', refreshToken, {
        ...cookieOptions,
        maxAge: 7 * 24 * 60 * 60 * 1000 // 7 å¤©
      })

      // æ›´æ–°æœ€å¾Œç™»å…¥æ™‚é–“
      await user.update({ lastLogin: new Date() })

      res.status(201).json({
        success: true,
        message: 'è¨»å†ŠæˆåŠŸ',
        user: user.toJSON()
      })

    } catch (error) {
      console.error('Register error:', error)
      res.status(500).json({
        success: false,
        message: 'è¨»å†Šå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦'
      })
    }
  }

  // ç™»å…¥åŠŸèƒ½
  async login(req, res) {
    try {
      const { email, password } = req.body

      // è¼¸å…¥é©—è­‰
      if (!email || !password) {
        return res.status(400).json({
          success: false,
          message: 'è«‹è¼¸å…¥é›»å­éƒµä»¶å’Œå¯†ç¢¼'
        })
      }

      // æŸ¥æ‰¾ä½¿ç”¨è€…
      const user = await User.findOne({ where: { email } })
      if (!user) {
        return res.status(401).json({
          success: false,
          message: 'é›»å­éƒµä»¶æˆ–å¯†ç¢¼éŒ¯èª¤'
        })
      }

      // æª¢æŸ¥å¸³æˆ¶ç‹€æ…‹
      if (!user.isActive) {
        return res.status(401).json({
          success: false,
          message: 'å¸³æˆ¶å·²è¢«åœç”¨ï¼Œè«‹è¯ç¹«ç®¡ç†å“¡'
        })
      }

      // é©—è­‰å¯†ç¢¼
      const isPasswordValid = await user.comparePassword(password)
      if (!isPasswordValid) {
        return res.status(401).json({
          success: false,
          message: 'é›»å­éƒµä»¶æˆ–å¯†ç¢¼éŒ¯èª¤'
        })
      }

      // ç”Ÿæˆ JWT tokens
      const accessToken = generateAccessToken(user)
      const refreshToken = generateRefreshToken(user)

      // è¨­å®šå®‰å…¨ cookies
      const cookieOptions = {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        path: '/'
      }

      res.cookie('access_token', accessToken, {
        ...cookieOptions,
        maxAge: 60 * 60 * 1000 // 1 å°æ™‚
      })

      res.cookie('refresh_token', refreshToken, {
        ...cookieOptions,
        maxAge: 7 * 24 * 60 * 60 * 1000 // 7 å¤©
      })

      // æ›´æ–°æœ€å¾Œç™»å…¥æ™‚é–“
      await user.update({ lastLogin: new Date() })

      res.json({
        success: true,
        message: 'ç™»å…¥æˆåŠŸ',
        user: user.toJSON()
      })

    } catch (error) {
      console.error('Login error:', error)
      res.status(500).json({
        success: false,
        message: 'ç™»å…¥å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦'
      })
    }
  }

  // ç™»å‡ºåŠŸèƒ½
  async logout(req, res) {
    try {
      // æ¸…é™¤ cookies
      res.clearCookie('access_token', { path: '/' })
      res.clearCookie('refresh_token', { path: '/' })

      res.json({
        success: true,
        message: 'ç™»å‡ºæˆåŠŸ'
      })
    } catch (error) {
      console.error('Logout error:', error)
      res.status(500).json({
        success: false,
        message: 'ç™»å‡ºå¤±æ•—'
      })
    }
  }

  // ç²å–ç•¶å‰ä½¿ç”¨è€…è³‡è¨Š
  async getCurrentUser(req, res) {
    try {
      // req.user ç”±èªè­‰ä¸­ä»‹è»Ÿé«”è¨­å®š
      const user = await User.findByPk(req.user.id)
      
      if (!user) {
        return res.status(404).json({
          success: false,
          message: 'ä½¿ç”¨è€…ä¸å­˜åœ¨'
        })
      }

      res.json({
        success: true,
        user: user.toJSON()
      })
    } catch (error) {
      console.error('Get current user error:', error)
      res.status(500).json({
        success: false,
        message: 'ç²å–ä½¿ç”¨è€…è³‡è¨Šå¤±æ•—'
      })
    }
  }

  // æ›´æ–°ä½¿ç”¨è€…è³‡æ–™
  async updateProfile(req, res) {
    try {
      const { name, avatarUrl } = req.body
      const userId = req.user.id

      const user = await User.findByPk(userId)
      if (!user) {
        return res.status(404).json({
          success: false,
          message: 'ä½¿ç”¨è€…ä¸å­˜åœ¨'
        })
      }

      // æ›´æ–°å…è¨±çš„æ¬„ä½
      const updateData = {}
      if (name) updateData.name = name
      if (avatarUrl) updateData.avatarUrl = avatarUrl

      await user.update(updateData)

      res.json({
        success: true,
        message: 'å€‹äººè³‡æ–™æ›´æ–°æˆåŠŸ',
        user: user.toJSON()
      })
    } catch (error) {
      console.error('Update profile error:', error)
      res.status(500).json({
        success: false,
        message: 'æ›´æ–°å€‹äººè³‡æ–™å¤±æ•—'
      })
    }
  }

  // Token åˆ·æ–°
  async refreshToken(req, res) {
    try {
      const refreshToken = req.cookies.refresh_token

      if (!refreshToken) {
        return res.status(401).json({
          success: false,
          message: 'Refresh token ä¸å­˜åœ¨'
        })
      }

      // é©—è­‰ refresh token
      const decoded = verifyToken(refreshToken, process.env.JWT_REFRESH_SECRET)
      const user = await User.findByPk(decoded.user_id)

      if (!user || !user.isActive) {
        return res.status(401).json({
          success: false,
          message: 'ç„¡æ•ˆçš„ refresh token'
        })
      }

      // ç”Ÿæˆæ–°çš„ access token
      const newAccessToken = generateAccessToken(user)

      res.cookie('access_token', newAccessToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        maxAge: 60 * 60 * 1000, // 1 å°æ™‚
        path: '/'
      })

      res.json({
        success: true,
        message: 'Token åˆ·æ–°æˆåŠŸ'
      })
    } catch (error) {
      console.error('Refresh token error:', error)
      res.status(401).json({
        success: false,
        message: 'Token åˆ·æ–°å¤±æ•—'
      })
    }
  }
}

export default new AuthController()
```

### 3. JWT å·¥å…·å‡½æ•¸

#### **JWT ç®¡ç†å¯¦ä½œ**
```javascript
// utils/jwt.js - å·²å¯¦ä½œ
import jwt from 'jsonwebtoken'

export const generateAccessToken = (user) => {
  return jwt.sign(
    {
      user_id: user.id,
      email: user.email,
      role: user.role,
      name: user.name
    },
    process.env.JWT_SECRET,
    { 
      expiresIn: process.env.JWT_EXPIRES_IN || '1h',
      issuer: 'gdg-portal',
      audience: 'gdg-portal-users'
    }
  )
}

export const generateRefreshToken = (user) => {
  return jwt.sign(
    {
      user_id: user.id,
      email: user.email,
      type: 'refresh'
    },
    process.env.JWT_REFRESH_SECRET,
    { 
      expiresIn: process.env.JWT_REFRESH_EXPIRES_IN || '7d',
      issuer: 'gdg-portal',
      audience: 'gdg-portal-users'
    }
  )
}

export const verifyToken = (token, secret = process.env.JWT_SECRET) => {
  try {
    return jwt.verify(token, secret, {
      issuer: 'gdg-portal',
      audience: 'gdg-portal-users'
    })
  } catch (error) {
    throw new Error('Token é©—è­‰å¤±æ•—: ' + error.message)
  }
}

export const decodeToken = (token) => {
  try {
    return jwt.decode(token)
  } catch (error) {
    return null
  }
}
```

### 4. èªè­‰ä¸­ä»‹è»Ÿé«”

#### **æ¬Šé™é©—è­‰ä¸­ä»‹è»Ÿé«”**
```javascript
// middlewares/auth.js - å·²å¯¦ä½œ
import { verifyToken } from '../utils/jwt.js'
import User from '../model/userModel.js'

// é©—è­‰ JWT Token
export const authenticateToken = async (req, res, next) => {
  try {
    const token = req.cookies.access_token

    if (!token) {
      return res.status(401).json({
        success: false,
        message: 'æœªæä¾›èªè­‰æ†‘è­‰'
      })
    }

    // é©—è­‰ token
    const decoded = verifyToken(token)
    
    // ç²å–å®Œæ•´ä½¿ç”¨è€…è³‡è¨Š
    const user = await User.findByPk(decoded.user_id)
    
    if (!user || !user.isActive) {
      return res.status(401).json({
        success: false,
        message: 'ç„¡æ•ˆçš„èªè­‰æ†‘è­‰'
      })
    }

    // å°‡ä½¿ç”¨è€…è³‡è¨ŠåŠ å…¥ request
    req.user = user
    next()
  } catch (error) {
    console.error('Authentication error:', error)
    
    // Token éæœŸï¼Œå˜—è©¦ä½¿ç”¨ refresh token
    if (error.message.includes('expired')) {
      return res.status(401).json({
        success: false,
        message: 'Token å·²éæœŸ',
        code: 'TOKEN_EXPIRED'
      })
    }
    
    return res.status(401).json({
      success: false,
      message: 'èªè­‰å¤±æ•—'
    })
  }
}

// å¯é¸èªè­‰ (ç”¨æ–¼éœ€è¦æª¢æŸ¥ä½†ä¸å¼·åˆ¶ç™»å…¥çš„ç«¯é»)
export const optionalAuth = async (req, res, next) => {
  try {
    const token = req.cookies.access_token
    
    if (token) {
      const decoded = verifyToken(token)
      const user = await User.findByPk(decoded.user_id)
      
      if (user && user.isActive) {
        req.user = user
      }
    }
    
    next()
  } catch (error) {
    // å¿½ç•¥éŒ¯èª¤ï¼Œç¹¼çºŒåŸ·è¡Œ
    next()
  }
}

// ç®¡ç†å“¡æ¬Šé™æª¢æŸ¥
export const requireAdmin = (req, res, next) => {
  if (!req.user) {
    return res.status(401).json({
      success: false,
      message: 'éœ€è¦ç™»å…¥'
    })
  }

  if (req.user.role !== 'admin') {
    return res.status(403).json({
      success: false,
      message: 'éœ€è¦ç®¡ç†å“¡æ¬Šé™'
    })
  }

  next()
}

// æœƒå“¡æ¬Šé™æª¢æŸ¥ (æ’é™¤è¨ªå®¢)
export const requireMember = (req, res, next) => {
  if (!req.user) {
    return res.status(401).json({
      success: false,
      message: 'éœ€è¦ç™»å…¥'
    })
  }

  if (req.user.role === 'guest') {
    return res.status(403).json({
      success: false,
      message: 'éœ€è¦æœƒå“¡æ¬Šé™'
    })
  }

  next()
}

// è‡ªå·±æˆ–ç®¡ç†å“¡æ¬Šé™ (ç”¨æ–¼å€‹äººè³‡æ–™ç·¨è¼¯ç­‰)
export const requireSelfOrAdmin = (req, res, next) => {
  if (!req.user) {
    return res.status(401).json({
      success: false,
      message: 'éœ€è¦ç™»å…¥'
    })
  }

  const targetUserId = parseInt(req.params.userId || req.params.id)
  
  if (req.user.role === 'admin' || req.user.id === targetUserId) {
    next()
  } else {
    return res.status(403).json({
      success: false,
      message: 'æ¬Šé™ä¸è¶³'
    })
  }
}
```

### 5. èªè­‰è·¯ç”±

#### **å®Œæ•´è·¯ç”±å¯¦ä½œ**
```javascript
// routes/auth_routes.js - å·²å¯¦ä½œ
import express from 'express'
import passport from 'passport'
import AuthController from '../controllers/userController.js'
import { authenticateToken, optionalAuth } from '../middlewares/auth.js'
import rateLimit from 'express-rate-limit'

const router = express.Router()

// Rate limiting for auth endpoints
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 åˆ†é˜
  max: 5, // æœ€å¤š 5 æ¬¡å˜—è©¦
  message: {
    success: false,
    message: 'å˜—è©¦æ¬¡æ•¸éå¤šï¼Œè«‹ 15 åˆ†é˜å¾Œå†è©¦'
  },
  standardHeaders: true,
  legacyHeaders: false
})

// å‚³çµ±èªè­‰è·¯ç”±
router.post('/register', authLimiter, AuthController.register)
router.post('/login', authLimiter, AuthController.login)
router.post('/logout', AuthController.logout)
router.post('/refresh', AuthController.refreshToken)

// ä½¿ç”¨è€…è³‡è¨Šè·¯ç”±
router.get('/me', authenticateToken, AuthController.getCurrentUser)
router.put('/me', authenticateToken, AuthController.updateProfile)

// Google OAuth è·¯ç”±
router.get('/google', 
  passport.authenticate('google', { 
    scope: ['profile', 'email'],
    session: false 
  })
)

router.get('/google/callback',
  passport.authenticate('google', { 
    session: false,
    failureRedirect: `${process.env.FRONTEND_URL}/login?error=oauth_failed`
  }),
  async (req, res) => {
    try {
      const user = req.user
      
      // ç”Ÿæˆ JWT tokens
      const accessToken = generateAccessToken(user)
      const refreshToken = generateRefreshToken(user)
      
      // è¨­å®šå®‰å…¨ cookies
      const cookieOptions = {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        path: '/'
      }

      res.cookie('access_token', accessToken, {
        ...cookieOptions,
        maxAge: 60 * 60 * 1000 // 1 å°æ™‚
      })

      res.cookie('refresh_token', refreshToken, {
        ...cookieOptions,
        maxAge: 7 * 24 * 60 * 60 * 1000 // 7 å¤©
      })

      // æ›´æ–°æœ€å¾Œç™»å…¥æ™‚é–“
      await user.update({ lastLogin: new Date() })
      
      // é‡å®šå‘åˆ°å‰ç«¯
      res.redirect(`${process.env.FRONTEND_URL}/?login=success`)
    } catch (error) {
      console.error('Google OAuth callback error:', error)
      res.redirect(`${process.env.FRONTEND_URL}/login?error=oauth_error`)
    }
  }
)

// é©—è­‰ç‹€æ…‹æª¢æŸ¥ (å…¬é–‹ç«¯é»)
router.get('/status', optionalAuth, (req, res) => {
  res.json({
    success: true,
    isAuthenticated: !!req.user,
    user: req.user ? req.user.toJSON() : null
  })
})

export default router
```

### 6. Passport Google OAuth è¨­å®š

#### **Google OAuth ç­–ç•¥å¯¦ä½œ**
```javascript
// config/passport.js - å·²å¯¦ä½œ
import passport from 'passport'
import { Strategy as GoogleStrategy } from 'passport-google-oauth20'
import User from '../model/userModel.js'

// Google OAuth ç­–ç•¥
passport.use(new GoogleStrategy({
  clientID: process.env.GOOGLE_CLIENT_ID,
  clientSecret: process.env.GOOGLE_CLIENT_SECRET,
  callbackURL: "/api/auth/google/callback"
}, async (accessToken, refreshToken, profile, done) => {
  try {
    console.log('Google OAuth Profile:', profile.id, profile.emails[0].value)
    
    // æª¢æŸ¥æ˜¯å¦å·²æœ‰æ­¤ Google ID çš„ä½¿ç”¨è€…
    let user = await User.findOne({ 
      where: { googleId: profile.id } 
    })
    
    if (user) {
      console.log('Found existing user with Google ID')
      return done(null, user)
    }
    
    // æª¢æŸ¥æ˜¯å¦æœ‰ç›¸åŒ email çš„ä½¿ç”¨è€…ï¼ˆç”¨æ–¼å¸³è™Ÿç¶å®šï¼‰
    user = await User.findOne({ 
      where: { email: profile.emails[0].value } 
    })
    
    if (user) {
      console.log('Found existing user with same email, linking Google account')
      // ç¶å®š Google å¸³è™Ÿåˆ°ç¾æœ‰ä½¿ç”¨è€…
      user.googleId = profile.id
      if (profile.photos && profile.photos.length > 0) {
        user.avatarUrl = profile.photos[0].value
      }
      user.emailVerified = true // Google å¸³è™Ÿé è¨­å·²é©—è­‰
      await user.save()
      return done(null, user)
    }
    
    // å‰µå»ºæ–°ä½¿ç”¨è€…
    console.log('Creating new user for Google account')
    user = await User.create({
      googleId: profile.id,
      name: profile.displayName,
      email: profile.emails[0].value,
      avatarUrl: profile.photos && profile.photos.length > 0 ? profile.photos[0].value : null,
      role: 'member', // Google ç™»å…¥çš„ä½¿ç”¨è€…é è¨­ç‚ºæœƒå“¡
      emailVerified: true,
      isActive: true
    })
    
    console.log('New user created:', user.id)
    return done(null, user)
    
  } catch (error) {
    console.error('Google OAuth Strategy Error:', error)
    return done(error, null)
  }
}))

// åºåˆ—åŒ–ä½¿ç”¨è€… (é›–ç„¶æˆ‘å€‘ä¸ä½¿ç”¨ sessionï¼Œä½† passport ä»éœ€è¦é€™äº›å‡½æ•¸)
passport.serializeUser((user, done) => {
  done(null, user.id)
})

passport.deserializeUser(async (id, done) => {
  try {
    const user = await User.findByPk(id)
    done(null, user)
  } catch (error) {
    done(error, null)
  }
})

export default passport
```

### 7. è³‡æ–™åº«é…ç½®

#### **MySQL é€£ç·šè¨­å®š**
```javascript
// config/database.js - å·²å¯¦ä½œ
import { Sequelize } from 'sequelize'

// å»ºç«‹ Sequelize å¯¦ä¾‹
export const sequelize = new Sequelize(
  process.env.DB_NAME || 'gdg_portal',
  process.env.DB_USER || 'root',
  process.env.DB_PASSWORD || '',
  {
    host: process.env.DB_HOST || 'localhost',
    port: process.env.DB_PORT || 3306,
    dialect: 'mysql',
    logging: process.env.NODE_ENV === 'development' ? console.log : false,
    pool: {
      max: 5,
      min: 0,
      acquire: 30000,
      idle: 10000
    },
    define: {
      timestamps: true,
      underscored: false,
      freezeTableName: true
    }
  }
)

// æ¸¬è©¦è³‡æ–™åº«é€£ç·š
export const testConnection = async () => {
  try {
    await sequelize.authenticate()
    console.log('âœ… è³‡æ–™åº«é€£ç·šæˆåŠŸ')
    return true
  } catch (error) {
    console.error('âŒ è³‡æ–™åº«é€£ç·šå¤±æ•—:', error.message)
    return false
  }
}

// åŒæ­¥è³‡æ–™åº«æ¨¡å‹
export const syncDatabase = async (force = false) => {
  try {
    await sequelize.sync({ force })
    console.log('âœ… è³‡æ–™åº«æ¨¡å‹åŒæ­¥å®Œæˆ')
    return true
  } catch (error) {
    console.error('âŒ è³‡æ–™åº«æ¨¡å‹åŒæ­¥å¤±æ•—:', error.message)
    return false
  }
}
```

### 8. ä¸»æ‡‰ç”¨ç¨‹å¼è¨­å®š

#### **Express ä¼ºæœå™¨è¨­å®š**
```javascript
// index.js - èªè­‰ç›¸é—œé…ç½®
import express from 'express'
import cors from 'cors'
import cookieParser from 'cookie-parser'
import passport from './config/passport.js'
import { testConnection, syncDatabase } from './config/database.js'
import authRoutes from './routes/auth_routes.js'

const app = express()

// åŸºæœ¬ä¸­ä»‹è»Ÿé«”
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true, // é‡è¦ï¼šå…è¨± cookies
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}))

app.use(express.json({ limit: '10mb' }))
app.use(express.urlencoded({ extended: true }))
app.use(cookieParser()) // é‡è¦ï¼šè§£æ cookies

// Passport åˆå§‹åŒ–
app.use(passport.initialize())

// è·¯ç”±è¨­å®š
app.use('/api/auth', authRoutes)

// å•Ÿå‹•ä¼ºæœå™¨
const PORT = process.env.PORT || 5000

const startServer = async () => {
  try {
    // æ¸¬è©¦è³‡æ–™åº«é€£ç·š
    const dbConnected = await testConnection()
    if (!dbConnected) {
      throw new Error('ç„¡æ³•é€£æ¥åˆ°è³‡æ–™åº«')
    }

    // åŒæ­¥è³‡æ–™åº« (é–‹ç™¼ç’°å¢ƒ)
    if (process.env.NODE_ENV === 'development') {
      await syncDatabase()
    }

    app.listen(PORT, () => {
      console.log(`ğŸš€ ä¼ºæœå™¨é‹è¡Œåœ¨ http://localhost:${PORT}`)
      console.log(`ğŸ“± å‰ç«¯ URL: ${process.env.FRONTEND_URL}`)
      console.log(`ğŸ” èªè­‰ç«¯é»: http://localhost:${PORT}/api/auth`)
    })
  } catch (error) {
    console.error('âŒ ä¼ºæœå™¨å•Ÿå‹•å¤±æ•—:', error.message)
    process.exit(1)
  }
}

startServer()
```

---
