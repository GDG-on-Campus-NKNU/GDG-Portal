# GDG Portal 後端系統設計文檔

## 📋 專案概述

本文檔分析 GDG on Campus NKNU Portal 的前端需求，並規劃完整的後端架構，包含 API 設計、資料表結構、控制器邏輯和業務模型。

**專案技術棧：**
- 前端：React + Vite + Tailwind CSS + Framer Motion
- 後端：Node.js + Express + MySQL + Sequelize ORM
- 驗證：JWT + Google OAuth 2.0
- 部署：需要考慮 Proxy 設定和環境變數

---

## 🎯 前端需求分析

### 現有頁面和功能

1. **首頁 (Home)** - 展示最新公告、統計數據、即將到來的活動
2. **公告頁面 (Announcements)** - 公告列表、搜尋、標籤篩選、置頂公告
3. **活動頁面 (Events)** - 活動列表、行事曆檢視、活動詳情
4. **核心團隊頁面 (CoreTeam)** - 幹部列表、成員詳情、分類篩選
5. **登入/註冊頁面 (Auth)** - 使用者驗證、Google OAuth 整合
6. **活動相簿 (Gallery)** - 活動照片、篩選功能
7. **歷史活動 (Historical Events)** - 過往活動記錄

### 前端 Hook 使用

```javascript
// useAnnouncementData.js
GET /api/announcements?page=1&limit=5&keyword=&tags=&isPinned=true

// useEventData.js  
GET /api/events?page=1&limit=5&keyword=&tags=&future=true&sort=desc
GET /api/events/:id

// useCoreTeamData.js
GET /api/coreteam?page=1&limit=20&keyword=&categories=
GET /api/coreteam/:id
GET /api/coreteam/options/categories

// useGalleryData.js
GET /api/gallery?page=1&limit=12&keyword=&eventType=&year=&tags=
GET /api/gallery/:id
GET /api/gallery/featured?limit=6
GET /api/gallery/stats
PATCH /api/gallery/:id/view

// useAuth.js - 新增的認證系統 Hook
POST /api/auth/register
POST /api/auth/login
POST /api/auth/logout
GET /api/auth/me
POST /api/auth/refresh
GET /api/auth/google
GET /api/auth/google/callback
```

### 前端認證狀態管理

```javascript
// AuthContext.jsx - 全域認證狀態管理
const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null)
  const [isAuthenticated, setIsAuthenticated] = useState(false)
  const [loading, setLoading] = useState(true)
  
  // 自動載入使用者資訊
  // JWT Token 管理
  // Google OAuth 處理
  // 登入/登出/註冊功能
}
```

---

## 🔐 使用者驗證系統架構

### 1. 認證流程設計

#### **混合驗證策略**
本系統支援兩種認證方式：
1. **傳統郵件密碼認證** - 適用於需要自訂權限的內部使用者
2. **Google OAuth 2.0 認證** - 適用於一般訪客和會員快速登入

#### **權限角色系統 (RBAC)**
```javascript
// 角色權限定義
const ROLES = {
  admin: {
    name: '管理員',
    permissions: ['CREATE', 'READ', 'UPDATE', 'DELETE', 'MANAGE_USERS']
  },
  member: {
    name: '會員',
    permissions: ['READ', 'CREATE_COMMENT', 'REGISTER_EVENT']
  },
  guest: {
    name: '訪客',
    permissions: ['READ']
  }
}
```

#### **JWT Token 架構**
```javascript
// Token 結構
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 3600
}

// JWT Payload
{
  "user_id": 123,
  "email": "user@example.com",
  "role": "member",
  "iat": 1640995200,
  "exp": 1640998800
}
```

### 2. Cookie 管理策略

#### **安全 Cookie 設定**
```javascript
// 後端 Cookie 設定
const cookieOptions = {
  httpOnly: true,        // 防止 XSS 攻擊
  secure: process.env.NODE_ENV === 'production', // HTTPS only
  sameSite: 'strict',    // CSRF 保護
  maxAge: 24 * 60 * 60 * 1000, // 24 小時
  path: '/'
}

// 設定認證 Cookie
res.cookie('access_token', accessToken, cookieOptions)
res.cookie('refresh_token', refreshToken, {
  ...cookieOptions,
  maxAge: 7 * 24 * 60 * 60 * 1000 // 7 天
})
```

#### **前端 Cookie 讀取**
```javascript
// utils/cookieUtils.js
export const getCookie = (name) => {
  const value = `; ${document.cookie}`;
  const parts = value.split(`; ${name}=`);
  if (parts.length === 2) return parts.pop().split(';').shift();
}

export const deleteCookie = (name) => {
  document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
}
```

### 3. 前端認證 Hook 實作

#### **useAuth Hook 完整實作**
```javascript
// hooks/useAuth.js
import { createContext, useContext, useState, useEffect } from 'react'

const AuthContext = createContext()

export const useAuth = () => {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider')
  }
  return context
}

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null)
  const [isAuthenticated, setIsAuthenticated] = useState(false)
  const [loading, setLoading] = useState(true)

  // 初始化：檢查現有登入狀態
  useEffect(() => {
    checkAuthStatus()
  }, [])

  const checkAuthStatus = async () => {
    try {
      const response = await fetch('/api/auth/me', {
        credentials: 'include' // 包含 cookies
      })
      
      if (response.ok) {
        const userData = await response.json()
        setUser(userData.user)
        setIsAuthenticated(true)
      }
    } catch (error) {
      console.error('Auth check failed:', error)
    } finally {
      setLoading(false)
    }
  }

  // 註冊功能
  const register = async (email, password, name) => {
    try {
      const response = await fetch('/api/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ email, password, name })
      })

      const data = await response.json()
      
      if (response.ok) {
        setUser(data.user)
        setIsAuthenticated(true)
        return { success: true, user: data.user }
      } else {
        return { success: false, message: data.message }
      }
    } catch (error) {
      return { success: false, message: '註冊失敗，請稍後再試' }
    }
  }

  // 登入功能
  const login = async (email, password) => {
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ email, password })
      })

      const data = await response.json()
      
      if (response.ok) {
        setUser(data.user)
        setIsAuthenticated(true)
        return { success: true, user: data.user }
      } else {
        return { success: false, message: data.message }
      }
    } catch (error) {
      return { success: false, message: '登入失敗，請稍後再試' }
    }
  }

  // 登出功能
  const logout = async () => {
    try {
      await fetch('/api/auth/logout', {
        method: 'POST',
        credentials: 'include'
      })
    } catch (error) {
      console.error('Logout error:', error)
    } finally {
      setUser(null)
      setIsAuthenticated(false)
    }
  }

  // 更新使用者資料
  const updateUser = async (userData) => {
    try {
      const response = await fetch('/api/auth/me', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(userData)
      })

      if (response.ok) {
        const updatedUser = await response.json()
        setUser(updatedUser.user)
        return { success: true, user: updatedUser.user }
      }
    } catch (error) {
      return { success: false, message: '更新失敗' }
    }
  }

  const value = {
    user,
    isAuthenticated,
    loading,
    login,
    register,
    logout,
    updateUser,
    checkAuthStatus
  }

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  )
}
```

### 4. 路由保護機制

#### **ProtectedRoute 組件**
```javascript
// pages/ProtectedRoute.jsx
import { useAuth } from '../hooks/useAuth'
import { Navigate, useLocation } from 'react-router-dom'

export default function ProtectedRoute({ children, requiredRole = null }) {
  const { isAuthenticated, user, loading } = useAuth()
  const location = useLocation()

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-blue-600"></div>
      </div>
    )
  }

  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />
  }

  // 角色權限檢查
  if (requiredRole && user?.role !== requiredRole) {
    return <Navigate to="/unauthorized" replace />
  }

  return children
}
```

#### **路由配置示例**
```javascript
// App.jsx 路由設定
import { AuthProvider } from './hooks/useAuth'
import ProtectedRoute from './pages/ProtectedRoute'

function App() {
  return (
    <AuthProvider>
      <Routes>
        {/* 公開路由 */}
        <Route path="/" element={<Home />} />
        <Route path="/login" element={<LoginPage />} />
        <Route path="/register" element={<RegisterPage />} />
        
        {/* 需要登入的路由 */}
        <Route path="/dashboard" element={
          <ProtectedRoute>
            <DashboardPage />
          </ProtectedRoute>
        } />
        
        {/* 需要管理員權限的路由 */}
        <Route path="/admin/*" element={
          <ProtectedRoute requiredRole="admin">
            <AdminPanel />
          </ProtectedRoute>
        } />
      </Routes>
    </AuthProvider>
  )
}
```

### 5. 使用者儀表板實作

#### **DashboardPage 組件**
```javascript
// pages/dashboard/DashboardPage.jsx
import { useState } from 'react'
import { useAuth } from '../../hooks/useAuth'
import { motion } from 'framer-motion'

export default function DashboardPage() {
  const { user, updateUser, logout } = useAuth()
  const [activeTab, setActiveTab] = useState('profile')
  const [loading, setLoading] = useState(false)

  const tabs = [
    { id: 'profile', name: '個人資料', icon: '👤' },
    { id: 'security', name: '安全設定', icon: '🔒' },
    { id: 'activities', name: '活動記錄', icon: '📅' }
  ]

  const handleUpdateProfile = async (formData) => {
    setLoading(true)
    const result = await updateUser(formData)
    setLoading(false)
    
    if (result.success) {
      // 顯示成功訊息
    } else {
      // 顯示錯誤訊息
    }
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* 側邊欄導航 */}
      <div className="flex">
        <aside className="w-64 bg-white shadow-sm">
          <div className="p-6">
            <div className="flex items-center space-x-3">
              <img 
                src={user?.avatarUrl || '/default-avatar.png'} 
                alt={user?.name}
                className="w-12 h-12 rounded-full"
              />
              <div>
                <h3 className="font-semibold">{user?.name}</h3>
                <p className="text-sm text-gray-500">{user?.email}</p>
              </div>
            </div>
          </div>
          
          <nav className="mt-6">
            {tabs.map((tab) => (
              <button
                key={tab.id}
                onClick={() => setActiveTab(tab.id)}
                className={`w-full flex items-center px-6 py-3 text-left hover:bg-gray-50 ${
                  activeTab === tab.id ? 'bg-blue-50 border-r-2 border-blue-500' : ''
                }`}
              >
                <span className="mr-3">{tab.icon}</span>
                {tab.name}
              </button>
            ))}
          </nav>
        </aside>

        {/* 主要內容區域 */}
        <main className="flex-1 p-8">
          {activeTab === 'profile' && (
            <ProfileTab user={user} onUpdate={handleUpdateProfile} loading={loading} />
          )}
          {activeTab === 'security' && (
            <SecurityTab user={user} />
          )}
          {activeTab === 'activities' && (
            <ActivitiesTab user={user} />
          )}
        </main>
      </div>
    </div>
  )
}
```

### 6. Google OAuth 整合

#### **後端 Passport 設定**
```javascript
// config/passport.js
import passport from 'passport'
import { Strategy as GoogleStrategy } from 'passport-google-oauth20'
import User from '../model/userModel.js'

passport.use(new GoogleStrategy({
  clientID: process.env.GOOGLE_CLIENT_ID,
  clientSecret: process.env.GOOGLE_CLIENT_SECRET,
  callbackURL: "/api/auth/google/callback"
}, async (accessToken, refreshToken, profile, done) => {
  try {
    // 檢查使用者是否已存在
    let user = await User.findOne({ where: { googleId: profile.id } })
    
    if (user) {
      return done(null, user)
    }
    
    // 檢查是否有相同 email 的帳號
    user = await User.findOne({ where: { email: profile.emails[0].value } })
    
    if (user) {
      // 更新現有帳號的 Google ID
      user.googleId = profile.id
      user.avatarUrl = profile.photos[0].value
      await user.save()
      return done(null, user)
    }
    
    // 創建新使用者
    user = await User.create({
      googleId: profile.id,
      name: profile.displayName,
      email: profile.emails[0].value,
      avatarUrl: profile.photos[0].value,
      role: 'member'
    })
    
    return done(null, user)
  } catch (error) {
    return done(error, null)
  }
}))
```

#### **Google OAuth 路由**
```javascript
// routes/auth_routes.js
router.get('/google', 
  passport.authenticate('google', { scope: ['profile', 'email'] })
)

router.get('/google/callback',
  passport.authenticate('google', { session: false }),
  async (req, res) => {
    try {
      const user = req.user
      const accessToken = generateAccessToken(user)
      const refreshToken = generateRefreshToken(user)
      
      // 設定 Cookie
      res.cookie('access_token', accessToken, cookieOptions)
      res.cookie('refresh_token', refreshToken, {
        ...cookieOptions,
        maxAge: 7 * 24 * 60 * 60 * 1000 // 7 天
      })
      
      // 重定向到前端
      res.redirect('http://localhost:3000/?login=success')
    } catch (error) {
      res.redirect('http://localhost:3000/?login=error')
    }
  }
)
```

### 7. 環境變數配置

#### **完整 .env 設定**
```bash
# /workspaces/GDG-Portal/server/.env
NODE_ENV=development
PORT=5000

# 資料庫設定
DB_HOST=localhost
DB_PORT=3306
DB_NAME=gdg_portal
DB_USER=gdg_user
DB_PASSWORD=your_secure_password

# JWT 設定
JWT_SECRET=your-super-secret-jwt-key-at-least-32-characters-long
JWT_REFRESH_SECRET=your-super-secret-refresh-key-different-from-access
JWT_EXPIRES_IN=1h
JWT_REFRESH_EXPIRES_IN=7d

# Google OAuth 設定
GOOGLE_CLIENT_ID=your-google-client-id.googleusercontent.com
GOOGLE_CLIENT_SECRET=your-google-client-secret

# 前端 URL (用於 CORS 和重定向)
FRONTEND_URL=http://localhost:3000

# Session 設定
SESSION_SECRET=your-session-secret-key

# 上傳設定
UPLOAD_DIR=uploads
MAX_FILE_SIZE=5242880
```

### 8. 測試和使用說明

#### **本機開發環境啟動**
```bash
# 1. 啟動後端伺服器
cd /workspaces/GDG-Portal/server
npm install
npm run dev

# 2. 啟動前端開發伺服器
cd /workspaces/GDG-Portal/client
npm install
npm run dev

# 3. 訪問應用程式
# 前端: http://localhost:3000
# 後端 API: http://localhost:5000
```

#### **功能測試清單**
```bash
# 使用者註冊測試
curl -X POST http://localhost:5000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"test123","name":"Test User"}'

# 使用者登入測試
curl -X POST http://localhost:5000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"test123"}' \
  -c cookies.txt

# 獲取使用者資訊測試
curl -X GET http://localhost:5000/api/auth/me \
  -b cookies.txt

# Google OAuth 測試
# 直接在瀏覽器訪問: http://localhost:5000/api/auth/google
```

#### **權限測試**
```javascript
// 測試不同角色的 API 存取
const testRoleAccess = async (role) => {
  // 管理員功能測試
  if (role === 'admin') {
    await testCreateEvent()
    await testDeleteAnnouncement()
    await testManageUsers()
  }
  
  // 會員功能測試
  if (role === 'member') {
    await testEventRegistration()
    await testProfileUpdate()
  }
  
  // 訪客功能測試 (無需認證)
  await testPublicContent()
}
```

---

## 🏗️ 後端認證系統實作

### 1. 使用者模型 (User Model)

#### **資料表結構**
```sql
-- 已實作的使用者表
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    google_id VARCHAR(255) UNIQUE,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255), -- 用於傳統登入
    name VARCHAR(100) NOT NULL,
    avatar_url TEXT,
    role ENUM('admin', 'member', 'guest') DEFAULT 'guest',
    is_active BOOLEAN DEFAULT true,
    last_login TIMESTAMP NULL,
    email_verified BOOLEAN DEFAULT false,
    verification_token VARCHAR(255),
    reset_password_token VARCHAR(255),
    reset_password_expires TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

#### **Sequelize 模型定義**
```javascript
// model/userModel.js - 已實作
import { DataTypes } from 'sequelize'
import { sequelize } from '../config/database.js'
import bcrypt from 'bcryptjs'

const User = sequelize.define('User', {
  id: {
    type: DataTypes.INTEGER,
    primaryKey: true,
    autoIncrement: true
  },
  googleId: {
    type: DataTypes.STRING,
    unique: true,
    allowNull: true
  },
  email: {
    type: DataTypes.STRING,
    unique: true,
    allowNull: false,
    validate: {
      isEmail: true
    }
  },
  passwordHash: {
    type: DataTypes.STRING,
    allowNull: true // Google 登入使用者可能沒有密碼
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  avatarUrl: {
    type: DataTypes.TEXT,
    allowNull: true
  },
  role: {
    type: DataTypes.ENUM('admin', 'member', 'guest'),
    defaultValue: 'guest'
  },
  isActive: {
    type: DataTypes.BOOLEAN,
    defaultValue: true
  },
  lastLogin: {
    type: DataTypes.DATE,
    allowNull: true
  },
  emailVerified: {
    type: DataTypes.BOOLEAN,
    defaultValue: false
  }
}, {
  tableName: 'users',
  timestamps: true,
  hooks: {
    beforeCreate: async (user) => {
      if (user.passwordHash) {
        user.passwordHash = await bcrypt.hash(user.passwordHash, 12)
      }
    },
    beforeUpdate: async (user) => {
      if (user.changed('passwordHash')) {
        user.passwordHash = await bcrypt.hash(user.passwordHash, 12)
      }
    }
  }
})

// 實例方法
User.prototype.comparePassword = async function(candidatePassword) {
  if (!this.passwordHash) return false
  return await bcrypt.compare(candidatePassword, this.passwordHash)
}

User.prototype.toJSON = function() {
  const user = this.get()
  delete user.passwordHash
  delete user.verificationToken
  delete user.resetPasswordToken
  return user
}

export default User
```

### 2. 認證控制器 (AuthController)

#### **完整實作**
```javascript
// controllers/userController.js - 已實作
import User from '../model/userModel.js'
import { generateAccessToken, generateRefreshToken, verifyToken } from '../utils/jwt.js'
import bcrypt from 'bcryptjs'

class AuthController {
  // 註冊功能
  async register(req, res) {
    try {
      const { email, password, name } = req.body

      // 輸入驗證
      if (!email || !password || !name) {
        return res.status(400).json({
          success: false,
          message: '請填寫所有必填欄位'
        })
      }

      // 檢查密碼強度
      if (password.length < 6) {
        return res.status(400).json({
          success: false,
          message: '密碼長度至少需要 6 個字元'
        })
      }

      // 檢查是否已存在相同 email
      const existingUser = await User.findOne({ where: { email } })
      if (existingUser) {
        return res.status(409).json({
          success: false,
          message: '此電子郵件已被註冊'
        })
      }

      // 創建新使用者
      const user = await User.create({
        email,
        passwordHash: password, // 會在 hook 中自動加密
        name,
        role: 'member', // 預設為會員
        emailVerified: true // 簡化版本，直接設為已驗證
      })

      // 生成 JWT tokens
      const accessToken = generateAccessToken(user)
      const refreshToken = generateRefreshToken(user)

      // 設定安全 cookies
      const cookieOptions = {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        path: '/'
      }

      res.cookie('access_token', accessToken, {
        ...cookieOptions,
        maxAge: 60 * 60 * 1000 // 1 小時
      })

      res.cookie('refresh_token', refreshToken, {
        ...cookieOptions,
        maxAge: 7 * 24 * 60 * 60 * 1000 // 7 天
      })

      // 更新最後登入時間
      await user.update({ lastLogin: new Date() })

      res.status(201).json({
        success: true,
        message: '註冊成功',
        user: user.toJSON()
      })

    } catch (error) {
      console.error('Register error:', error)
      res.status(500).json({
        success: false,
        message: '註冊失敗，請稍後再試'
      })
    }
  }

  // 登入功能
  async login(req, res) {
    try {
      const { email, password } = req.body

      // 輸入驗證
      if (!email || !password) {
        return res.status(400).json({
          success: false,
          message: '請輸入電子郵件和密碼'
        })
      }

      // 查找使用者
      const user = await User.findOne({ where: { email } })
      if (!user) {
        return res.status(401).json({
          success: false,
          message: '電子郵件或密碼錯誤'
        })
      }

      // 檢查帳戶狀態
      if (!user.isActive) {
        return res.status(401).json({
          success: false,
          message: '帳戶已被停用，請聯繫管理員'
        })
      }

      // 驗證密碼
      const isPasswordValid = await user.comparePassword(password)
      if (!isPasswordValid) {
        return res.status(401).json({
          success: false,
          message: '電子郵件或密碼錯誤'
        })
      }

      // 生成 JWT tokens
      const accessToken = generateAccessToken(user)
      const refreshToken = generateRefreshToken(user)

      // 設定安全 cookies
      const cookieOptions = {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        path: '/'
      }

      res.cookie('access_token', accessToken, {
        ...cookieOptions,
        maxAge: 60 * 60 * 1000 // 1 小時
      })

      res.cookie('refresh_token', refreshToken, {
        ...cookieOptions,
        maxAge: 7 * 24 * 60 * 60 * 1000 // 7 天
      })

      // 更新最後登入時間
      await user.update({ lastLogin: new Date() })

      res.json({
        success: true,
        message: '登入成功',
        user: user.toJSON()
      })

    } catch (error) {
      console.error('Login error:', error)
      res.status(500).json({
        success: false,
        message: '登入失敗，請稍後再試'
      })
    }
  }

  // 登出功能
  async logout(req, res) {
    try {
      // 清除 cookies
      res.clearCookie('access_token', { path: '/' })
      res.clearCookie('refresh_token', { path: '/' })

      res.json({
        success: true,
        message: '登出成功'
      })
    } catch (error) {
      console.error('Logout error:', error)
      res.status(500).json({
        success: false,
        message: '登出失敗'
      })
    }
  }

  // 獲取當前使用者資訊
  async getCurrentUser(req, res) {
    try {
      // req.user 由認證中介軟體設定
      const user = await User.findByPk(req.user.id)
      
      if (!user) {
        return res.status(404).json({
          success: false,
          message: '使用者不存在'
        })
      }

      res.json({
        success: true,
        user: user.toJSON()
      })
    } catch (error) {
      console.error('Get current user error:', error)
      res.status(500).json({
        success: false,
        message: '獲取使用者資訊失敗'
      })
    }
  }

  // 更新使用者資料
  async updateProfile(req, res) {
    try {
      const { name, avatarUrl } = req.body
      const userId = req.user.id

      const user = await User.findByPk(userId)
      if (!user) {
        return res.status(404).json({
          success: false,
          message: '使用者不存在'
        })
      }

      // 更新允許的欄位
      const updateData = {}
      if (name) updateData.name = name
      if (avatarUrl) updateData.avatarUrl = avatarUrl

      await user.update(updateData)

      res.json({
        success: true,
        message: '個人資料更新成功',
        user: user.toJSON()
      })
    } catch (error) {
      console.error('Update profile error:', error)
      res.status(500).json({
        success: false,
        message: '更新個人資料失敗'
      })
    }
  }

  // Token 刷新
  async refreshToken(req, res) {
    try {
      const refreshToken = req.cookies.refresh_token

      if (!refreshToken) {
        return res.status(401).json({
          success: false,
          message: 'Refresh token 不存在'
        })
      }

      // 驗證 refresh token
      const decoded = verifyToken(refreshToken, process.env.JWT_REFRESH_SECRET)
      const user = await User.findByPk(decoded.user_id)

      if (!user || !user.isActive) {
        return res.status(401).json({
          success: false,
          message: '無效的 refresh token'
        })
      }

      // 生成新的 access token
      const newAccessToken = generateAccessToken(user)

      res.cookie('access_token', newAccessToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        maxAge: 60 * 60 * 1000, // 1 小時
        path: '/'
      })

      res.json({
        success: true,
        message: 'Token 刷新成功'
      })
    } catch (error) {
      console.error('Refresh token error:', error)
      res.status(401).json({
        success: false,
        message: 'Token 刷新失敗'
      })
    }
  }
}

export default new AuthController()
```

### 3. JWT 工具函數

#### **JWT 管理實作**
```javascript
// utils/jwt.js - 已實作
import jwt from 'jsonwebtoken'

export const generateAccessToken = (user) => {
  return jwt.sign(
    {
      user_id: user.id,
      email: user.email,
      role: user.role,
      name: user.name
    },
    process.env.JWT_SECRET,
    { 
      expiresIn: process.env.JWT_EXPIRES_IN || '1h',
      issuer: 'gdg-portal',
      audience: 'gdg-portal-users'
    }
  )
}

export const generateRefreshToken = (user) => {
  return jwt.sign(
    {
      user_id: user.id,
      email: user.email,
      type: 'refresh'
    },
    process.env.JWT_REFRESH_SECRET,
    { 
      expiresIn: process.env.JWT_REFRESH_EXPIRES_IN || '7d',
      issuer: 'gdg-portal',
      audience: 'gdg-portal-users'
    }
  )
}

export const verifyToken = (token, secret = process.env.JWT_SECRET) => {
  try {
    return jwt.verify(token, secret, {
      issuer: 'gdg-portal',
      audience: 'gdg-portal-users'
    })
  } catch (error) {
    throw new Error('Token 驗證失敗: ' + error.message)
  }
}

export const decodeToken = (token) => {
  try {
    return jwt.decode(token)
  } catch (error) {
    return null
  }
}
```

### 4. 認證中介軟體

#### **權限驗證中介軟體**
```javascript
// middlewares/auth.js - 已實作
import { verifyToken } from '../utils/jwt.js'
import User from '../model/userModel.js'

// 驗證 JWT Token
export const authenticateToken = async (req, res, next) => {
  try {
    const token = req.cookies.access_token

    if (!token) {
      return res.status(401).json({
        success: false,
        message: '未提供認證憑證'
      })
    }

    // 驗證 token
    const decoded = verifyToken(token)
    
    // 獲取完整使用者資訊
    const user = await User.findByPk(decoded.user_id)
    
    if (!user || !user.isActive) {
      return res.status(401).json({
        success: false,
        message: '無效的認證憑證'
      })
    }

    // 將使用者資訊加入 request
    req.user = user
    next()
  } catch (error) {
    console.error('Authentication error:', error)
    
    // Token 過期，嘗試使用 refresh token
    if (error.message.includes('expired')) {
      return res.status(401).json({
        success: false,
        message: 'Token 已過期',
        code: 'TOKEN_EXPIRED'
      })
    }
    
    return res.status(401).json({
      success: false,
      message: '認證失敗'
    })
  }
}

// 可選認證 (用於需要檢查但不強制登入的端點)
export const optionalAuth = async (req, res, next) => {
  try {
    const token = req.cookies.access_token
    
    if (token) {
      const decoded = verifyToken(token)
      const user = await User.findByPk(decoded.user_id)
      
      if (user && user.isActive) {
        req.user = user
      }
    }
    
    next()
  } catch (error) {
    // 忽略錯誤，繼續執行
    next()
  }
}

// 管理員權限檢查
export const requireAdmin = (req, res, next) => {
  if (!req.user) {
    return res.status(401).json({
      success: false,
      message: '需要登入'
    })
  }

  if (req.user.role !== 'admin') {
    return res.status(403).json({
      success: false,
      message: '需要管理員權限'
    })
  }

  next()
}

// 會員權限檢查 (排除訪客)
export const requireMember = (req, res, next) => {
  if (!req.user) {
    return res.status(401).json({
      success: false,
      message: '需要登入'
    })
  }

  if (req.user.role === 'guest') {
    return res.status(403).json({
      success: false,
      message: '需要會員權限'
    })
  }

  next()
}

// 自己或管理員權限 (用於個人資料編輯等)
export const requireSelfOrAdmin = (req, res, next) => {
  if (!req.user) {
    return res.status(401).json({
      success: false,
      message: '需要登入'
    })
  }

  const targetUserId = parseInt(req.params.userId || req.params.id)
  
  if (req.user.role === 'admin' || req.user.id === targetUserId) {
    next()
  } else {
    return res.status(403).json({
      success: false,
      message: '權限不足'
    })
  }
}
```

### 5. 認證路由

#### **完整路由實作**
```javascript
// routes/auth_routes.js - 已實作
import express from 'express'
import passport from 'passport'
import AuthController from '../controllers/userController.js'
import { authenticateToken, optionalAuth } from '../middlewares/auth.js'
import rateLimit from 'express-rate-limit'

const router = express.Router()

// Rate limiting for auth endpoints
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 分鐘
  max: 5, // 最多 5 次嘗試
  message: {
    success: false,
    message: '嘗試次數過多，請 15 分鐘後再試'
  },
  standardHeaders: true,
  legacyHeaders: false
})

// 傳統認證路由
router.post('/register', authLimiter, AuthController.register)
router.post('/login', authLimiter, AuthController.login)
router.post('/logout', AuthController.logout)
router.post('/refresh', AuthController.refreshToken)

// 使用者資訊路由
router.get('/me', authenticateToken, AuthController.getCurrentUser)
router.put('/me', authenticateToken, AuthController.updateProfile)

// Google OAuth 路由
router.get('/google', 
  passport.authenticate('google', { 
    scope: ['profile', 'email'],
    session: false 
  })
)

router.get('/google/callback',
  passport.authenticate('google', { 
    session: false,
    failureRedirect: `${process.env.FRONTEND_URL}/login?error=oauth_failed`
  }),
  async (req, res) => {
    try {
      const user = req.user
      
      // 生成 JWT tokens
      const accessToken = generateAccessToken(user)
      const refreshToken = generateRefreshToken(user)
      
      // 設定安全 cookies
      const cookieOptions = {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        path: '/'
      }

      res.cookie('access_token', accessToken, {
        ...cookieOptions,
        maxAge: 60 * 60 * 1000 // 1 小時
      })

      res.cookie('refresh_token', refreshToken, {
        ...cookieOptions,
        maxAge: 7 * 24 * 60 * 60 * 1000 // 7 天
      })

      // 更新最後登入時間
      await user.update({ lastLogin: new Date() })
      
      // 重定向到前端
      res.redirect(`${process.env.FRONTEND_URL}/?login=success`)
    } catch (error) {
      console.error('Google OAuth callback error:', error)
      res.redirect(`${process.env.FRONTEND_URL}/login?error=oauth_error`)
    }
  }
)

// 驗證狀態檢查 (公開端點)
router.get('/status', optionalAuth, (req, res) => {
  res.json({
    success: true,
    isAuthenticated: !!req.user,
    user: req.user ? req.user.toJSON() : null
  })
})

export default router
```

### 6. Passport Google OAuth 設定

#### **Google OAuth 策略實作**
```javascript
// config/passport.js - 已實作
import passport from 'passport'
import { Strategy as GoogleStrategy } from 'passport-google-oauth20'
import User from '../model/userModel.js'

// Google OAuth 策略
passport.use(new GoogleStrategy({
  clientID: process.env.GOOGLE_CLIENT_ID,
  clientSecret: process.env.GOOGLE_CLIENT_SECRET,
  callbackURL: "/api/auth/google/callback"
}, async (accessToken, refreshToken, profile, done) => {
  try {
    console.log('Google OAuth Profile:', profile.id, profile.emails[0].value)
    
    // 檢查是否已有此 Google ID 的使用者
    let user = await User.findOne({ 
      where: { googleId: profile.id } 
    })
    
    if (user) {
      console.log('Found existing user with Google ID')
      return done(null, user)
    }
    
    // 檢查是否有相同 email 的使用者（用於帳號綁定）
    user = await User.findOne({ 
      where: { email: profile.emails[0].value } 
    })
    
    if (user) {
      console.log('Found existing user with same email, linking Google account')
      // 綁定 Google 帳號到現有使用者
      user.googleId = profile.id
      if (profile.photos && profile.photos.length > 0) {
        user.avatarUrl = profile.photos[0].value
      }
      user.emailVerified = true // Google 帳號預設已驗證
      await user.save()
      return done(null, user)
    }
    
    // 創建新使用者
    console.log('Creating new user for Google account')
    user = await User.create({
      googleId: profile.id,
      name: profile.displayName,
      email: profile.emails[0].value,
      avatarUrl: profile.photos && profile.photos.length > 0 ? profile.photos[0].value : null,
      role: 'member', // Google 登入的使用者預設為會員
      emailVerified: true,
      isActive: true
    })
    
    console.log('New user created:', user.id)
    return done(null, user)
    
  } catch (error) {
    console.error('Google OAuth Strategy Error:', error)
    return done(error, null)
  }
}))

// 序列化使用者 (雖然我們不使用 session，但 passport 仍需要這些函數)
passport.serializeUser((user, done) => {
  done(null, user.id)
})

passport.deserializeUser(async (id, done) => {
  try {
    const user = await User.findByPk(id)
    done(null, user)
  } catch (error) {
    done(error, null)
  }
})

export default passport
```

### 7. 資料庫配置

#### **MySQL 連線設定**
```javascript
// config/database.js - 已實作
import { Sequelize } from 'sequelize'

// 建立 Sequelize 實例
export const sequelize = new Sequelize(
  process.env.DB_NAME || 'gdg_portal',
  process.env.DB_USER || 'root',
  process.env.DB_PASSWORD || '',
  {
    host: process.env.DB_HOST || 'localhost',
    port: process.env.DB_PORT || 3306,
    dialect: 'mysql',
    logging: process.env.NODE_ENV === 'development' ? console.log : false,
    pool: {
      max: 5,
      min: 0,
      acquire: 30000,
      idle: 10000
    },
    define: {
      timestamps: true,
      underscored: false,
      freezeTableName: true
    }
  }
)

// 測試資料庫連線
export const testConnection = async () => {
  try {
    await sequelize.authenticate()
    console.log('✅ 資料庫連線成功')
    return true
  } catch (error) {
    console.error('❌ 資料庫連線失敗:', error.message)
    return false
  }
}

// 同步資料庫模型
export const syncDatabase = async (force = false) => {
  try {
    await sequelize.sync({ force })
    console.log('✅ 資料庫模型同步完成')
    return true
  } catch (error) {
    console.error('❌ 資料庫模型同步失敗:', error.message)
    return false
  }
}
```

### 8. 主應用程式設定

#### **Express 伺服器設定**
```javascript
// index.js - 認證相關配置
import express from 'express'
import cors from 'cors'
import cookieParser from 'cookie-parser'
import passport from './config/passport.js'
import { testConnection, syncDatabase } from './config/database.js'
import authRoutes from './routes/auth_routes.js'

const app = express()

// 基本中介軟體
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true, // 重要：允許 cookies
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}))

app.use(express.json({ limit: '10mb' }))
app.use(express.urlencoded({ extended: true }))
app.use(cookieParser()) // 重要：解析 cookies

// Passport 初始化
app.use(passport.initialize())

// 路由設定
app.use('/api/auth', authRoutes)

// 啟動伺服器
const PORT = process.env.PORT || 5000

const startServer = async () => {
  try {
    // 測試資料庫連線
    const dbConnected = await testConnection()
    if (!dbConnected) {
      throw new Error('無法連接到資料庫')
    }

    // 同步資料庫 (開發環境)
    if (process.env.NODE_ENV === 'development') {
      await syncDatabase()
    }

    app.listen(PORT, () => {
      console.log(`🚀 伺服器運行在 http://localhost:${PORT}`)
      console.log(`📱 前端 URL: ${process.env.FRONTEND_URL}`)
      console.log(`🔐 認證端點: http://localhost:${PORT}/api/auth`)
    })
  } catch (error) {
    console.error('❌ 伺服器啟動失敗:', error.message)
    process.exit(1)
  }
}

startServer()
```

---
